<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width">
        <title>Kotlin と AppAuth for Android でネイティブアプリの実装サンプルを作ってみた &mdash; 実験メモとかいろいろ</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/modern5plus.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/font-awesome.min.css" type="text/css">
        <link rel="shortcut icon" href="../../../_static/favicon.ico" /><!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="OpenAM内蔵のOpenDJをSCIM 2.0サーバーとして構成する" href="../../../2016/06/06/config_opendj_as_a_scim_server.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="../../../_static/google_analytics.js"></script>

    <script type="text/javascript">
        $(document).ready(function () {
            // Adjusts document height if sidebar is taller
            var documentwrapper = document.getElementsByTagName("article")[0];
            var sidebar = document.getElementsByClassName("sidebar")[0];

            if (sidebar.offsetHeight > documentwrapper.offsetHeight)
            {
                var mainwrapper = document.getElementsByClassName("main")[0];
                documentwrapper.style.minHeight = mainwrapper.offsetHeight + "px";
            }

            // Scroll to content if on small screen
            if (screen.width < 480)
            {
                $(document).scrollTop(document.getElementsByTagName("article")[0].offsetTop - 44);
            }
        });
    </script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><header role="banner">
            <hgroup>
              <h1><a href="../../../index.html">実験メモとかいろいろ</a></h1><h2>python, xperia, debian, oidc 辺りを中心に</h2></hgroup>
          </header>
      <nav role="navigation">
            <ul><li class="quicklink"><div class="rss">
        <a href="../../../rss.html" title="Subscribe via RSS"><span class="fa fa-lg fa-rss"></span></a>
    </div></li><li class="main-nav">
                  <a href="../../../index.html">ホーム</a>
                </li>
              </ul>
          </nav><div class="main-container" role="main"><div class="main wrapper body clearfix"><article role="article"><ul class="related clearfix">
            <li class="left"></li>
            <li class="right"><a href="../../../2016/06/06/config_opendj_as_a_scim_server.html">OpenAM内蔵のOpenDJをSCIM 2.0サーバーとして構成する</a> &raquo; </li>
        </ul><div class="timestamp postmeta">
            <span>November 04, 2017</span>
        </div>
    <div class="section" id="kotlin-appauth-for-android">
<h1>Kotlin と AppAuth for Android でネイティブアプリの実装サンプルを作ってみた</h1>
<p>スマホ、タブレット向けにネイティブアプリを提供する場合、ほとんどの場合は何かしらのバックエンドAPIを使用していることでしょう。</p>
<p>バックエンドAPIアクセス時の認証・アクセス認可の実装には様々な方法がありますが、今後は OAuth 2.0 の仕様群に準じたものになっていくものと思います。</p>
<p>ネイティブアプリでの OAuth 2.0 の実装については [RFC 8252][BCP 212] OAuth 2.0 for Native Apps として現時点のベストプラクティスがまとめられています。
また、そのプラクティスに沿った実装を支援するオープンソースライブラリ AppAuth が公開されています。</p>
<p>今回はその Android 版のライブラリ AppAuth for Android を用いて実装サンプルを作ってみました。</p>
<div id="more"> </div><div class="contents local topic" id="id1">
<p class="topic-title first">もくじ</p>
<ul class="simple">
<li><a class="reference internal" href="#id2" id="id17">作った実装サンプル</a></li>
<li><a class="reference internal" href="#oauth-2-0" id="id18">なぜ OAuth 2.0 になっていくのか？</a></li>
<li><a class="reference internal" href="#appauth-for-android" id="id19">AppAuth for Android を使って簡単に実装する</a></li>
<li><a class="reference internal" href="#id3" id="id20">アプリから見た処理ステップ</a></li>
<li><a class="reference internal" href="#api" id="id21">「認証・アクセス認可要求」～「バックエンドAPIアクセス」の実装</a><ul>
<li><a class="reference internal" href="#id4" id="id22">アクセストークン更新時のエラー処理の考え方</a></li>
<li><a class="reference internal" href="#id5" id="id23">バックエンドAPIアクセス時のエラー処理の考え方</a></li>
<li><a class="reference internal" href="#id6" id="id24">「認証・アクセス認可要求」の実装</a></li>
<li><a class="reference internal" href="#id7" id="id25">「認証・認可結果、アクセストークン受取」の実装</a></li>
<li><a class="reference internal" href="#id8" id="id26">「アクセストークン更新」～「バックエンドAPIアクセス」の実装</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9" id="id27">「アクセストークンの無効化」の実装</a></li>
<li><a class="reference internal" href="#id10" id="id28">「アクセストークンの保管」の実装</a></li>
<li><a class="reference internal" href="#id11" id="id29">所感</a></li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id1">作った実装サンプル</a></h2>
<p>この実装サンプルは、ネイティブアプリで必要となるであろう「サインイン」、「バックエンドAPIアクセス」、「サインアウト」の機能について、 AppAuth での実装方法と動きを確認するために作ったものです。</p>
<div class="figure align-right" id="id13">
<a class="reference internal image-reference" href="../../../_images/20171030_making_kotlin_appauth_android_demo_application_1.png"><img alt="**図1: 画面イメージ**" src="../../../_images/20171030_making_kotlin_appauth_android_demo_application_1.png" style="width: 135.0px; height: 240.0px;" /></a>
<p class="caption"><span class="caption-text"><strong>図1: 画面イメージ</strong></span></p>
</div>
<p>Google Accounts の UserInfo エンドポイントをバックエンドAPIに見立て、そのアクセスのための認証・アクセス認可を Google Accounts で行ないます。</p>
<p>画面上部の「サインイン」、「API呼出し」、「サインアウト」の各ボタンをタップすることでそれぞれの動作を確認できます。
動作の結果やそれに伴い変化する AppAuth の内部状態を、下部の「appAuthState (Summary)」、「Response」、「appAuthState (Full)」の各テキストエリアに表示します。</p>
<p>この実装サンプルのソースコードは、 GitHub 上で MIT License で公開しています。
ビルド済みのAPKファイルも収録してます。早速コードを見てみたい、動かしてみたいという方はこちらをどうぞ。</p>
<ul class="simple">
<li>Kotlin + AppAuth for Android ネイティブアプリ実装サンプル <span class="raw-html"><br></span>
<a class="reference external" href="https://github.com/paoneJP/AppAuthDemo-Android">https://github.com/paoneJP/AppAuthDemo-Android</a></li>
</ul>
<p>以下では、実装する上でポイントとなる点について、いくつか書いてみたいと思います。</p>
</div>
<div class="section" id="oauth-2-0">
<h2><a class="toc-backref" href="#id1">なぜ OAuth 2.0 になっていくのか？</a></h2>
<p>現在のネイティブアプリでのサインインの実装は、アプリの画面にユーザーIDとパスワードを入力するフォームを作り、独自に認証とバックエンドAPIへのアクセス認可を処理する方式が主流になっています。</p>
<p>アプリの利用を広げていく上で、この方式には次の2つの観点で課題があります。</p>
<ol class="arabic simple">
<li>複数のネイティブアプリを提供していく場合、ユーザーはアプリごとにサインインを行なう必要があり、使ってもらう際の操作が煩雑である。</li>
<li>ソーシャルアカウントを使った登録や認証、パスワード以外の認証方式への対応などを進める場合、個別にかつ独自の設計をアプリごとに行ない、実装する必要がある。</li>
</ol>
<p>これらの課題は、 OAuth 2.0 の仕様群に準じた実装を適用することで、次のように解決してくことができます。</p>
<ol class="arabic simple">
<li>OAuth 2.0 の Implicit Grant, Authroization Code Grant といったブラウザを介する認証・アクセス認可方式を適用することで、認証状態がブラウザで管理され、ネイティブアプリ間、ネイティブアプリとWebアプリ間でのシングルサインオンが実現できる。</li>
<li>認証機能はブラウザ側のUIで提供されるようになるため、認証方式の追加、変更についてネイティブアプリ側で個別に実装することなく対応ができる。</li>
</ol>
<p>一方で、 OAuth 2.0 の実装は、これまでのような『ユーザーIDとパスワードを POST して、APIアクセスのキーを受け取る』といった単純なリクエスト・レスポンスではなく、仕様に沿って正しく実装するには手間もかかり、少々ハードルが高いことも事実です。</p>
</div>
<div class="section" id="appauth-for-android">
<h2><a class="toc-backref" href="#id1">AppAuth for Android を使って簡単に実装する</a></h2>
<p>ネイティブアプリでの OAuth 2.0 の実装については [RFC 8252][BCP 212] OAuth 2.0 for Native Apps として現時点のベストプラクティスがまとめられています。
また、そのプラクティスに沿った実装を支援するオープンソースライブラリ AppAuth が公開されています。</p>
<ul class="simple">
<li>[RFC 8252][BCP 212] OAuth 2.0 for Native Apps<ul>
<li><a class="reference external" href="https://datatracker.ietf.org/doc/rfc8252/">https://datatracker.ietf.org/doc/rfc8252/</a></li>
<li><a class="reference external" href="https://datatracker.ietf.org/doc/bcp212/">https://datatracker.ietf.org/doc/bcp212/</a></li>
</ul>
</li>
<li>AppAuth for Android<ul>
<li><a class="reference external" href="https://openid.net/code/AppAuth">https://openid.net/code/AppAuth</a></li>
<li><a class="reference external" href="https://openid.net/code/AppAuth-Android">https://openid.net/code/AppAuth-Android</a></li>
</ul>
</li>
</ul>
<p>AppAuth のライブラリは Bintray からビルド済みのものを入手することができます。
Android Studio の File &gt; Project Structure… を開き、以下の2つの設定を行なうことで、プロジェクトに組み込むことができます。</p>
<ul class="simple">
<li>Library Repository に <span class="docutils literal"><span class="pre">'https://dl.bintray.com/openid/net.openid'</span></span> を追加</li>
<li>Dependencies に <span class="docutils literal"><span class="pre">net.openid:appauth:0.7.0</span></span> を追加</li>
</ul>
<div class="figure align-center" id="id14">
<a class="reference internal image-reference" href="../../../_images/20171030_making_kotlin_appauth_android_demo_application_2.png"><img alt="**図2: AppAuth ライブラリの組み込み**" src="../../../_images/20171030_making_kotlin_appauth_android_demo_application_2.png" style="width: 383.0px; height: 168.5px;" /></a>
<p class="caption"><span class="caption-text"><strong>図2: AppAuth ライブラリの組み込み</strong></span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>ビルド済み AppAuth ライブラリ バージョン 0.7.0 は com.android.support:customtabs バージョン 25.3.1 を使っています。（当記事執筆時点）</p>
<p class="last">そのため、ネイティブアプリのプロジェクトが使用する com.android.support ライブラリも同じバージョンとなるように調整をしておく必要があります。</p>
</div>
<p>AppAuth を利用すれば、ネイティブアプリの開発者はいくつかのメソッドを呼び出すだけで、簡単に OAuth 2.0 を使ったバックエンドAPIアクセス時の認証・アクセス認可の機能を自分のアプリケーションに組み込むことができます。</p>
<p>アプリが行なうべき OAuth 2.0 の仕様群に沿った動作のほとんどは AppAuthが適切に実行してくれます。
このため、ネイティブアプリの開発者は OAuth 2.0 の詳細の技術仕様を意識する必要はなく、大まかな処理のステップを把握しておくだけで実装を進めることができます。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id1">アプリから見た処理ステップ</a></h2>
<p>ネイティブアプリでは「サインイン」、「バックエンドAPIアクセス」、「サインアウト」の機能を実装することになります。
これを AppAuth を使って OAuth 2.0 に対応するように実装する場合、次の6つのステップを実装していきます。</p>
<div class="figure align-center" id="id15">
<a class="reference internal image-reference" href="../../../_images/20171030_making_kotlin_appauth_android_demo_application_3.png"><img alt="**図3: アプリから見た処理ステップ**" src="../../../_images/20171030_making_kotlin_appauth_android_demo_application_3.png" style="width: 515.0px; height: 302.0px;" /></a>
<p class="caption"><span class="caption-text"><strong>図3: アプリから見た処理ステップ</strong></span></p>
</div>
<p>それぞれのステップでは次のような処理を行ないます。</p>
<ol class="arabic simple">
<li>認証・アクセス認可を要求する<ul>
<li>認証・アクセス認可に使用するサーバーの情報を取得する。</li>
<li>Chrome Custom Tabs などのブラウザを使って認証・アクセス認可のリクエストを行なう。</li>
</ul>
</li>
<li>認証・アクセス認可の結果とアクセストークンを受け取る<ul>
<li>カスタムURIスキームへのリダイレクトを介して認証・アクセス認可結果を受け取る。</li>
<li>サーバーからアクセストークン、リフレッシュトークンを取得する。</li>
</ul>
</li>
<li>アクセストークンを更新する<ul>
<li>アクセストークンの有効期限が切れている場合は、リフレッシュトークンを使ってサーバーから新しいアクセストークンを取得する。</li>
</ul>
</li>
<li>バックエンドAPIにアクセスする<ul>
<li>アクセストークンを Authorization ヘッダに付けてAPIにアクセスする。</li>
</ul>
</li>
<li>アクセストークンを無効化する<ul>
<li>アクセストークンとリフレッシュトークンをアプリ内から破棄する。</li>
<li>この時、不要となるアクセストークンとリフレッシュトークンをサーバー側でも無効化することが望ましい。</li>
</ul>
</li>
<li>アクセストークンを永続データとして保管する<ul>
<li>一度サインインを完了した後はその状態を維持するため、アクセストークン、リフレッシュトークンを永続データとして保管する。</li>
<li>トークン漏洩リスクを軽減するため、暗号化を行なうことが望ましい。</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="api">
<h2><a class="toc-backref" href="#id1">「認証・アクセス認可要求」～「バックエンドAPIアクセス」の実装</a></h2>
<p>アプリの状態は、大きく (1) 未サインイン状態、(2) サインイン状態 の2つがあります。
それを念頭におくと、「認証・アクセス認可要求」～「バックエンドAPIアクセス」の4ステップの動きは下図のようにするのがよいでしょう。</p>
<div class="figure align-center" id="id16">
<a class="reference internal image-reference" href="../../../_images/20171030_making_kotlin_appauth_android_demo_application_4.png"><img alt="**図4: アプリの処理の流れ**" src="../../../_images/20171030_making_kotlin_appauth_android_demo_application_4.png" style="width: 462.0px; height: 444.0px;" /></a>
<p class="caption"><span class="caption-text"><strong>図4: アプリの処理の流れ</strong></span></p>
</div>
<p>特に注意をしたいのは「アクセストークン更新」の際のエラー処理と「バックエンドAPIアクセス」の際のエラー処理です。</p>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id1">アクセストークン更新時のエラー処理の考え方</a></h3>
<p>アクセストークンの更新は、「ネイティブアプリ」が「認証・アクセス認可サーバー」にリフレッシュトークンを提示することで、新しいアクセストークンを取得する処理になります。
この時に生じるエラーの要因として、次の2つが考えられます。</p>
<ol class="arabic simple">
<li>ネットワークエラーなどによる一時的な更新エラー</li>
<li>リフレッシュトークンが無効になったことによる恒久的な更新エラー</li>
</ol>
<p>前者の場合は、リトライにより再度APIアクセスが可能な状態であるため、アプリとしてはバックエンドAPIアクセス時の一時的なエラーとして処理を行ない、サインイン状態を保つのが良いでしょう。</p>
<p>一方後者の場合は、リトライをしても正常にアクセスできることはありません。アプリは未サインイン状態に遷移し（必要であればアプリ内のデータを初期化して）ユーザーにはサインインから処理をやり直してもらう必要があります。</p>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id1">バックエンドAPIアクセス時のエラー処理の考え方</a></h3>
<p>バックエンドAPIアクセス時のエラーの要因は、次の3つが考えられます。</p>
<ol class="arabic simple">
<li>APIのアプリロジックとしてのエラー</li>
<li>ネットワークエラーなどによる一時的なアクセスエラー</li>
<li>アクセストークンが無効化されたことによる恒久的なアクセスエラー</li>
</ol>
<p>この 1. と 2. のケースは、アプリの設計として取り決めたエラー処理をすれば良いケースです。
もちろんほとんどの場合でアプリはサインイン状態を保ったままとなります。</p>
<p>一方、3. のアクセストークンが無効化された場合のエラー処理は、慎重に考える必要があります。
このケースは、次の条件が重なったときに発生します。</p>
<ul class="simple">
<li>アプリが持つアクセストークンが有効期限内にある。</li>
<li>何かしらの理由により、サーバーサイドではアクセストークンが無効化されている。
（ユーザーがアプリの連携を解除したなど）</li>
</ul>
<p>この状態になるとユーザーは再度サインインを行なう必要があります。
そのため、アプリは未サインイン状態に遷移し（必要であればアプリ内のデータを初期化して）ユーザーにサインインを促すことになります。</p>
<p>この 3. の状態になっていることは、バックエンドAPIのレスポンスから判断する必要があります。
アプリの開発においては、バックエンドAPIのエラーレスポンスの仕様をよく確認する必要がありますし、もし自分でバックエンドAPIを開発する際は、3. の状態を検出できるようなエラーレスポンスを仕様に含めて、
設計と実装を行なう必要があります。</p>
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id1">「認証・アクセス認可要求」の実装</a></h3>
<p>「認証・アクセス認可を要求する」ステップでは、次の2つの処理を行ないます。</p>
<ul class="simple">
<li>認証・アクセス認可に使用するサーバーの情報を取得する。</li>
<li>Chrome Custom Tabs などのブラウザを使って認証・アクセス認可のリクエストを行なう。</li>
</ul>
<p>実装サンプルでは <span class="docutils literal"><span class="pre">startAuthorization()</span></span> の中でこの処理を実装しています。</p>
<div class="highlight-kotlin"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">fun</span> <span class="nf">startAuthorization</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">AuthorizationServiceConfiguration</span><span class="p">.</span><span class="n">fetchFromIssuer</span><span class="p">(</span><span class="n">Uri</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">ISSUER_URI</span><span class="p">),</span> <span class="p">{</span> <span class="n">config</span><span class="p">,</span> <span class="n">ex</span> <span class="p">-&gt;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">config</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">val</span> <span class="py">req</span> <span class="p">=</span> <span class="n">AuthorizationRequest</span>
                    <span class="p">.</span><span class="n">Builder</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">CLIENT_ID</span><span class="p">,</span> <span class="n">ResponseTypeValues</span><span class="p">.</span><span class="n">CODE</span><span class="p">,</span> <span class="n">Uri</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">REDIRECT_URI</span><span class="p">))</span>
                    <span class="p">.</span><span class="n">setScope</span><span class="p">(</span><span class="n">SCOPE</span><span class="p">)</span>
                    <span class="p">.</span><span class="n">build</span><span class="p">()</span>
            <span class="k">val</span> <span class="py">intent</span> <span class="p">=</span> <span class="n">AuthorizationService</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="n">getAuthorizationRequestIntent</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
            <span class="n">startActivityForResult</span><span class="p">(</span><span class="n">intent</span><span class="p">,</span> <span class="n">REQCODE_AUTH</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">val</span> <span class="py">m</span> <span class="p">=</span> <span class="n">Throwable</span><span class="p">().</span><span class="n">stackTrace</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
                <span class="n">Log</span><span class="p">.</span><span class="n">e</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span> <span class="s">&quot;${m}: ${ex}&quot;</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">whenAuthorizationFails</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<p>[<a class="reference external" href="https://github.com/paoneJP/AppAuthDemo-Android/blob/da5b3ba59bcd6221c1e19df21657f494047385c5/app/src/main/java/net/paonejp/kndzyb/appauthdemo/MainActivity.kt#L126-L143">⇒GitHubで見る</a>]</p>
<p>AppAuth の <span class="docutils literal"><span class="pre">AuthorizationServiceConfiguration.fetchFromIssuer()</span></span> のエラーは、コールバックの引数 <span class="docutils literal"><span class="pre">ex</span></span> で渡されます。エラーの場合は認証エラー時のアプリ共通処理を書いた <span class="docutils literal"><span class="pre">whenAuthorizationFails(ex)</span></span> を呼び出します。</p>
<p>このステップの処理を行なうと、 AppAuth に実装されている AuthorizationManagementActivity が起動され、 Chrome Custom Tabs などのブラウザを使った認証・アクセス認可のリクエストが行なわれます。</p>
</div>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id1">「認証・認可結果、アクセストークン受取」の実装</a></h3>
<p>「認証・アクセス認可の結果、アクセストークンを受け取る」ステップでは、次の2つの処理を行ないます。</p>
<ul class="simple">
<li>カスタムURIスキームへのリダイレクトを介して認証・アクセス認可結果を受け取る。</li>
<li>サーバーからアクセストークン、リフレッシュトークンを取得する。</li>
</ul>
<p>カスタムURIスキームでの結果の受け取りは、前述の AppAuth の AuthorizationManagementActivity がいい感じに処理してくれます。
その結果が AuthorizationManagementActivity からアプリに返されます。
その結果の受け取りを <span class="docutils literal"><span class="pre">onActivityResult()</span></span> に実装します。</p>
<div class="highlight-kotlin"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">fun</span> <span class="nf">onActivityResult</span><span class="p">(</span><span class="n">requestCode</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">resultCode</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="k">data</span><span class="p">:</span> <span class="n">Intent</span><span class="p">?)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">.</span><span class="n">onActivityResult</span><span class="p">(</span><span class="n">requestCode</span><span class="p">,</span> <span class="n">resultCode</span><span class="p">,</span> <span class="k">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">requestCode</span> <span class="p">==</span> <span class="n">REQCODE_AUTH</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">handleAuthorizationResponse</span><span class="p">(</span><span class="k">data</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>[<a class="reference external" href="https://github.com/paoneJP/AppAuthDemo-Android/blob/da5b3ba59bcd6221c1e19df21657f494047385c5/app/src/main/java/net/paonejp/kndzyb/appauthdemo/MainActivity.kt#L78-L83">⇒GitHubで見る</a>]</p>
<p>受け取った結果は <span class="docutils literal"><span class="pre">handleAuthorizationResponse()</span></span> の前半部分で処理しています。
AppAuth の状態は appAuthState オブジェクトに格納しており、受け取った結果を引数に入れて <span class="docutils literal"><span class="pre">update()</span></span> を呼び出すことで状態を更新します。</p>
<div class="highlight-kotlin"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">fun</span> <span class="nf">handleAuthorizationResponse</span><span class="p">(</span><span class="k">data</span><span class="p">:</span> <span class="n">Intent</span><span class="p">?)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">data</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">val</span> <span class="py">m</span> <span class="p">=</span> <span class="n">Throwable</span><span class="p">().</span><span class="n">stackTrace</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
        <span class="n">Log</span><span class="p">.</span><span class="n">e</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span> <span class="s">&quot;${m}: unexpected intent call&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">val</span> <span class="py">resp</span> <span class="p">=</span> <span class="n">AuthorizationResponse</span><span class="p">.</span><span class="n">fromIntent</span><span class="p">(</span><span class="k">data</span><span class="p">)</span>
    <span class="k">val</span> <span class="py">ex</span> <span class="p">=</span> <span class="n">AuthorizationException</span><span class="p">.</span><span class="n">fromIntent</span><span class="p">(</span><span class="k">data</span><span class="p">)</span>
    <span class="n">appAuthState</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">resp</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">||</span> <span class="n">resp</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">val</span> <span class="py">m</span> <span class="p">=</span> <span class="n">Throwable</span><span class="p">().</span><span class="n">stackTrace</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
        <span class="n">Log</span><span class="p">.</span><span class="n">e</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span> <span class="s">&quot;${m}: ${ex}&quot;</span><span class="p">)</span>
        <span class="n">whenAuthorizationFails</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>[<a class="reference external" href="https://github.com/paoneJP/AppAuthDemo-Android/blob/da5b3ba59bcd6221c1e19df21657f494047385c5/app/src/main/java/net/paonejp/kndzyb/appauthdemo/MainActivity.kt#L145-L162">⇒GitHubで見る</a>]</p>
<p>次に、受け取った結果を使い、サーバーからアクセストークン、リフレッシュトークンを取得します。
これは <span class="docutils literal"><span class="pre">handleAuthorizationResponse()</span></span> の後半部分に実装しています。</p>
<div class="highlight-kotlin"><div class="highlight"><pre><span></span>    <span class="n">AuthorizationService</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
            <span class="p">.</span><span class="n">performTokenRequest</span><span class="p">(</span><span class="n">resp</span><span class="p">.</span><span class="n">createTokenExchangeRequest</span><span class="p">(),</span> <span class="p">{</span> <span class="n">resp2</span><span class="p">,</span> <span class="n">ex2</span> <span class="p">-&gt;</span>
                <span class="n">appAuthState</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">resp2</span><span class="p">,</span> <span class="n">ex2</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">resp2</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">whenAuthorizationSucceeds</span><span class="p">()</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">whenAuthorizationFails</span><span class="p">(</span><span class="n">ex2</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<p>[<a class="reference external" href="https://github.com/paoneJP/AppAuthDemo-Android/blob/da5b3ba59bcd6221c1e19df21657f494047385c5/app/src/main/java/net/paonejp/kndzyb/appauthdemo/MainActivity.kt#L162-L172">⇒GitHubで見る</a>]</p>
<p>ここでも、実際のアクセストークン、リフレッシュトークンの取得は、 AppAuth の <span class="docutils literal"><span class="pre">AuthorizationService().performTokenRequest()</span></span> がいい感じに処理をしてくれて、結果がコールバックに返されます。</p>
<p>コールバックの中では <span class="docutils literal"><span class="pre">appAuthState.update()</span></span> を呼び出し、受け取った結果を使って AppAuth の状態を更新します。</p>
<p>前半の処理、後半の処理ともにエラー処理を行ない、エラーの場合は認証エラー時のアプリ共通処理を書いた <span class="docutils literal"><span class="pre">whenAuthorizationFails(ex)</span></span> を呼び出します。</p>
<p>アクセストークンの取得まで処理ができた場合は <span class="docutils literal"><span class="pre">whenAuthorizationSucceeds()</span></span> を呼び出し、以降はサインイン状態としてふるまうことになります。</p>
</div>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id1">「アクセストークン更新」～「バックエンドAPIアクセス」の実装</a></h3>
<p>「アクセストークンを更新する」～「バックエンドAPIにアクセスする」ステップは、AppAuth に実装されている <span class="docutils literal"><span class="pre">performActionWithFreshTokens()</span></span> を使うことで、一連の処理として実装することができます。</p>
<p><span class="docutils literal"><span class="pre">performActionWithFreshTokens()</span></span> は、現在のアクセストークンを引数に付けてコールバックを実行します。アクセストークンの有効期限が切れている場合は、リフレッシュトークンを使って新しいアクセストークンに更新した上でコールバックが実行されます。</p>
<p>通常ネイティブアプリが利用するバックエンドAPIは複数あり、それぞれに結果を処理するコールバックを用意することになります。それを念頭に実装サンプルでは、汎用的な関数を <span class="docutils literal"><span class="pre">httpGetJson()</span></span> として実装し、APIごとに専用のコールバックを指定して実行できるようにしています。</p>
<div class="highlight-kotlin"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">fun</span> <span class="nf">httpGetJson</span><span class="p">(</span><span class="n">uri</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
                        <span class="n">callback</span><span class="p">:</span> <span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">json</span><span class="p">:</span> <span class="n">JSONObject</span><span class="p">?,</span> <span class="n">ex</span><span class="p">:</span> <span class="n">Exception</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">service</span> <span class="p">=</span> <span class="n">AuthorizationService</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
    <span class="n">appAuthState</span><span class="p">.</span><span class="n">performActionWithFreshTokens</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="p">{</span> <span class="n">accessToken</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">ex</span> <span class="p">-&gt;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">val</span> <span class="py">m</span> <span class="p">=</span> <span class="n">Throwable</span><span class="p">().</span><span class="n">stackTrace</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
            <span class="n">Log</span><span class="p">.</span><span class="n">e</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span> <span class="s">&quot;${m}: ${ex}&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">appAuthState</span><span class="p">.</span><span class="n">isAuthorized</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">callback</span><span class="p">(</span><span class="n">X_HTTP_ERROR</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">callback</span><span class="p">(</span><span class="n">X_HTTP_NEED_REAUTHZ</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">accessToken</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">callback</span><span class="p">(</span><span class="n">X_HTTP_ERROR</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">HttpRequestJsonTask</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="n">accessToken</span><span class="p">,</span> <span class="p">{</span> <span class="n">code</span><span class="p">,</span> <span class="k">data</span><span class="p">,</span> <span class="n">ex2</span> <span class="p">-&gt;</span>
                    <span class="n">callback</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="k">data</span><span class="p">,</span> <span class="n">ex2</span><span class="p">)</span>
                <span class="p">}).</span><span class="n">execute</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<p>[<a class="reference external" href="https://github.com/paoneJP/AppAuthDemo-Android/blob/da5b3ba59bcd6221c1e19df21657f494047385c5/app/src/main/java/net/paonejp/kndzyb/appauthdemo/MainActivity.kt#L317-L339">⇒GitHubで見る</a>]</p>
<p>前半部分で、アクセストークン更新時のエラー処理をしています。エラーが返ってきたとき、もし AppAuth の状態 <span class="docutils literal"><span class="pre">appAuthState</span></span> の認証済み状態 <span class="docutils literal"><span class="pre">isAuthorized</span></span> が <span class="docutils literal"><span class="pre">false</span></span> になっている場合は恒久的な更新エラーが生じたものと判断し、再認証が必要なステータスを返すようにしています。</p>
<p>後半部分で、現在のアクセストークンをつけてAPIアクセスを行なっています。
この処理は非同期タスクで実行する必要があり、 <span class="docutils literal"><span class="pre">HttpRequestJsonTask</span></span> クラスを実装し処理しています。</p>
<p>実行結果は <span class="docutils literal"><span class="pre">httpGetJson()</span></span> 呼び出すときに引数に渡されたコールバック関数で処理します。
そのコールバックの実装例は次の通りです。</p>
<div class="highlight-kotlin"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">fun</span> <span class="nf">showApiResultCallback</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="k">data</span><span class="p">:</span> <span class="n">JSONObject</span><span class="p">?,</span> <span class="n">ex</span><span class="p">:</span> <span class="n">Exception</span><span class="p">?)</span> <span class="p">{</span>
    <span class="k">when</span> <span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">X_HTTP_NEED_REAUTHZ</span><span class="p">,</span> <span class="n">HTTP_UNAUTHORIZED</span> <span class="p">-&gt;</span> <span class="n">whenReauthorizationRequired</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>

        <span class="n">HTTP_OK</span> <span class="p">-&gt;</span> <span class="p">{</span>
            <span class="n">uResponseView</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;%s\n\n%s&quot;</span>
                    <span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="n">getText</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">msg_api_ok</span><span class="p">),</span>
                            <span class="k">data</span><span class="o">?.</span><span class="n">toString</span><span class="p">(</span><span class="m">2</span><span class="p">)</span><span class="o">?.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;\\/&quot;</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">))</span>
        <span class="p">}</span>

        <span class="k">else</span> <span class="p">-&gt;</span> <span class="p">{</span>
            <span class="n">uResponseView</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;%s\n\n%d\n%s\n%s&quot;</span>
                    <span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="n">getText</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">msg_api_error</span><span class="p">),</span>
                            <span class="n">code</span><span class="p">,</span> <span class="k">data</span> <span class="o">?:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">ex</span> <span class="o">?:</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">doShowAppAuthState</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>[<a class="reference external" href="https://github.com/paoneJP/AppAuthDemo-Android/blob/da5b3ba59bcd6221c1e19df21657f494047385c5/app/src/main/java/net/paonejp/kndzyb/appauthdemo/MainActivity.kt#L289-L306">⇒GitHubで見る</a>]</p>
<p>このコールバックは前述の通りAPIごとに実装されるものと考えられます。
再サインインが必要なエラーが返されている場合は、その状態を処理するアプリ共通処理 <span class="docutils literal"><span class="pre">whenReauthorizationRequired(ex)</span></span> を呼び出すようにしています。</p>
<p>コード <span class="docutils literal"><span class="pre">X_HTTP_NEED_REAUTHZ</span></span> は先に示した <span class="docutils literal"><span class="pre">httpGetJson()</span></span> でアクセストークンの更新が恒久的な更新エラーが生じたときに返されるものです。</p>
<p>コード <span class="docutils literal"><span class="pre">HTTP_UNAUTHORIZED</span></span> は、実装サンプルが呼び出している Google のAPIがアクセストークンが無効化された状態で呼び出されたときに返されるコードです。
この部分の条件は呼び出すAPIの仕様に合わせた実装が必要となるでしょう。</p>
</div>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id1">「アクセストークンの無効化」の実装</a></h2>
<p>ネイティブアプリでは、アプリの利用中止やユーザーの切り替えなどを理由に、ユーザー自身がサインアウトの処理を行えるような実装をすることがあります。
この時にアクセストークンを無効化します。</p>
<p>不要となったアクセストークン、リフレッシュトークンはアプリ内から破棄しますが、この時サーバー側ではトークンが有効なまま残ります。</p>
<p>アクセストークン、リフレッシュトークンを漏らさないように最大限の考慮をしてアプリを作っているという前提で言えば、サーバー側でトークンが有効なまま残っていることは大きな問題ではありませんが、不要となったトークンは明示的にかつ即座に無効化しておくに越したことはありません。</p>
<p>アクセストークンの無効化には、 OAuth 2.0 仕様群の一つである [RFC 7009] OAuth 2.0 Token Revocation に沿ったエンドポイントを利用します。</p>
<ul class="simple">
<li>[RFC 7009] OAuth 2.0 Token Revocation<ul>
<li><a class="reference external" href="https://datatracker.ietf.org/doc/rfc7009/">https://datatracker.ietf.org/doc/rfc7009/</a></li>
</ul>
</li>
</ul>
<p>当記事の執筆時点では AppAuth にはアクセストークン無効化の機能が実装されていないため、この部分は個別に実装を行ないます。実装サンプルでは <span class="docutils literal"><span class="pre">revokeAuthorization()</span></span> で実装しています。</p>
<p><span class="docutils literal"><span class="pre">revokeAuthorization()</span></span> の前半部分では、サーバーが Token Revocation をサポートしているかどうかの判定と、未サポートの場合のアプリ内のアクセストークンの破棄を行なっています。</p>
<div class="highlight-kotlin"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">fun</span> <span class="nf">revokeAuthorization</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">uri</span> <span class="p">=</span> <span class="n">appAuthState</span><span class="p">.</span><span class="n">authorizationServiceConfiguration</span><span class="o">?.</span><span class="n">discoveryDoc</span><span class="o">?.</span><span class="n">docJson</span>
            <span class="o">?.</span><span class="n">opt</span><span class="p">(</span><span class="s">&quot;revocation_endpoint&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">String</span><span class="p">?</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">uri</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">appAuthState</span> <span class="p">=</span> <span class="n">AuthState</span><span class="p">()</span>
        <span class="n">whenRevokeAuthorizationSucceeds</span><span class="p">()</span>
        <span class="k">return</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>[<a class="reference external" href="https://github.com/paoneJP/AppAuthDemo-Android/blob/da5b3ba59bcd6221c1e19df21657f494047385c5/app/src/main/java/net/paonejp/kndzyb/appauthdemo/MainActivity.kt#L189-L198">⇒GitHubで見る</a>]</p>
<p>サーバーが Token Revocation をサポートしてるかどうかは、サーバーの情報 (<span class="docutils literal"><span class="pre">/.well-known/openid-configuration</span></span> で提供される JSON ドキュメント) に、<span class="docutils literal"><span class="pre">revocation_endpoint</span></span> が記載されているかどうかで判定できます。</p>
<p>続いて <span class="docutils literal"><span class="pre">revokeAuthorization()</span></span> の後半部分ですが、ここでは OAuth 2.0 Token Revocation の仕様に従い、無効化するアクセストークンを <span class="docutils literal"><span class="pre">revocation_endpoint</span></span> に POST し、サーバーにアクセストークンの無効化をリクエストしています。</p>
<div class="highlight-kotlin"><div class="highlight"><pre><span></span>    <span class="k">val</span> <span class="py">param</span> <span class="p">=</span> <span class="s">&quot;token=${appAuthState.refreshToken}&amp;token_type_hint=refresh_token&quot;</span>
    <span class="n">HttpRequestJsonTask</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="p">{</span> <span class="n">code</span><span class="p">,</span> <span class="k">data</span><span class="p">,</span> <span class="n">ex</span> <span class="p">-&gt;</span>
        <span class="k">when</span> <span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">HTTP_OK</span> <span class="p">-&gt;</span> <span class="p">{</span>
                <span class="n">appAuthState</span> <span class="p">=</span> <span class="n">AuthState</span><span class="p">()</span>
                <span class="n">whenRevokeAuthorizationSucceeds</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="n">HTTP_BAD_REQUEST</span> <span class="p">-&gt;</span> <span class="p">{</span>

                <span class="c1">// RFC 7009 に示されているように、すでに無効なトークンの無効化リクエストに</span>
                <span class="c1">// 対しサーバーは HTTP 200 を応答するが、一部のサーバーはエラーを応答する</span>
                <span class="c1">// ことがある。Google Accounts の場合、 HTTP 400 で &quot;invalid_token&quot; エラー</span>
                <span class="c1">// を返すため、それを成功応答として処理する。</span>
                <span class="c1">// As described in RFC 7009, the server responds with HTTP 200 for revocation</span>
                <span class="c1">// request to already invalidated token, but some servers may respond with an</span>
                <span class="c1">// error. Google Accounts returns &quot;invalid_token&quot; error with HTTP 400, it must</span>
                <span class="c1">// be treated as a successful response.</span>
                <span class="k">if</span> <span class="p">(</span><span class="k">data</span><span class="o">?.</span><span class="n">optString</span><span class="p">(</span><span class="s">&quot;error&quot;</span><span class="p">)</span> <span class="p">==</span> <span class="s">&quot;invalid_token&quot;</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">appAuthState</span> <span class="p">=</span> <span class="n">AuthState</span><span class="p">()</span>
                    <span class="n">whenRevokeAuthorizationSucceeds</span><span class="p">()</span>
                    <span class="k">return</span><span class="n">@HttpRequestJsonTask</span>
                <span class="p">}</span>

                <span class="k">val</span> <span class="py">msg</span> <span class="p">=</span> <span class="s">&quot;Server returned HTTP response code: %d for URL: %s with message: %s&quot;</span>
                        <span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">uri</span><span class="p">,</span> <span class="k">data</span><span class="p">.</span><span class="n">toString</span><span class="p">())</span>
                <span class="n">whenRevokeAuthorizationFails</span><span class="p">(</span><span class="n">IOException</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
            <span class="p">}</span>

            <span class="k">else</span> <span class="p">-&gt;</span> <span class="n">whenRevokeAuthorizationFails</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}).</span><span class="n">execute</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>[<a class="reference external" href="https://github.com/paoneJP/AppAuthDemo-Android/blob/da5b3ba59bcd6221c1e19df21657f494047385c5/app/src/main/java/net/paonejp/kndzyb/appauthdemo/MainActivity.kt#L198-L231">⇒GitHubで見る</a>]</p>
<p>実装サンプルでは、</p>
<ul class="simple">
<li>サーバー側でアクセストークンの無効化ができれば、アプリ内のアクセストークンを破棄し、未サインイン状態とする</li>
<li>サーバー側でアクセストークンの無効化ができなければ、アプリ内のアクセストークンは破棄せず、サインイン状態を維持する</li>
</ul>
<p>という動作をするようにしています。</p>
<p>Google Accounts の場合、リフレッシュトークンの無効化を行なうと、対となるアクセストークンも無効化されるため、実装サンプルではリフレッシュトークンの無効化のみをリクエストしています。</p>
<p>アプリがアクセストークンの無効化をリクエストした際に、何かしらの理由でサーバー側でそのトークンが無効になっているケースがあり得ます。
OAuth 2.0 Token Revocation では、このような場合は正常にトークンが無効化できたものとしてHTTPステータス 200 を返すものとされています。</p>
<p>しかし Google Accounts の場合、HTTPステータス 400 で <span class="docutils literal"><span class="pre">invalid_token</span></span> というエラーが返されます。
実装サンプルではワークアラウンドとして、この時はサーバー側でアクセストークンが無効化できた正常応答として処理するようにしています。</p>
</div>
<div class="section" id="id10">
<h2><a class="toc-backref" href="#id1">「アクセストークンの保管」の実装</a></h2>
<p>ネイティブアプリでは、一度サインインを完了すると、ユーザーが明示的にサインアウトするなどのイベントが無い限りは、サインインしたままで利用することになります。</p>
<p>そのため、取得したアクセストークン、リフレッシュトークンは永続データとして保管し、アプリの再起動時やデバイスの再起動時に再ロードして利用するような実装が必要になります。</p>
<p>AppAuth ではアクセストークン、リフレッシュトークンを含め、必要な状態データが <span class="docutils literal"><span class="pre">appAuthState</span></span> オブジェクトに保存されており、これを <span class="docutils literal"><span class="pre">jsonSerializeString()</span></span> で文字列化し、SharedPreferences に書き出すことで永続化ができます。
永続化された状態は <span class="docutils literal"><span class="pre">AuthState.jsonDeserialize()</span></span> を使い、 <span class="docutils literal"><span class="pre">appAuthState</span></span> オブジェクトに復元できます。</p>
<p>Android での SharedPreferences の利用は、現在 <span class="docutils literal"><span class="pre">MODE_PRIVATE</span></span> だけに限定するようにガイドされており、そのデータには他のアプリからはアクセスできないようになっています。</p>
<p>しかし、保存先がファイルシステムであり、ファイルのパーミッションだけで制御されているため、予期せぬ状況下でこのデータが漏れ出す可能性を考慮すると、アクセストークン、リフレッシュトークンなどの重要な情報は安全な手続きで暗号化を行なったうえで保管することが、より望ましい実装といえます。</p>
<p>実装サンプルでは、 Android KeyStore System を使うことで、安全に暗号鍵を管理しつつ、<span class="docutils literal"><span class="pre">appAuthState</span></span> を暗号化して SharedPreferences に保管するように実装をしています。</p>
<p>Android KeyStore System がサポートする暗号化アルゴリズムは、 Android 6.0 以降と 5.x 以下で異なるため、 <span class="docutils literal"><span class="pre">Crypto.kt</span></span> の中で Android のバージョンを判定しそれぞれのバージョンに適した暗号化の処理をする <span class="docutils literal"><span class="pre">encryptString()</span></span>, <span class="docutils literal"><span class="pre">decryptString()</span></span> を実装して対応しています。</p>
<p><span class="docutils literal"><span class="pre">onPause()</span></span> の中での <span class="docutils literal"><span class="pre">appAuthState</span></span> の保管</p>
<div class="highlight-kotlin"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">fun</span> <span class="nf">onPause</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">.</span><span class="n">onPause</span><span class="p">()</span>

    <span class="n">getSharedPreferences</span><span class="p">(</span><span class="s">&quot;appAuthPreference&quot;</span><span class="p">,</span> <span class="n">MODE_PRIVATE</span><span class="p">)</span>
            <span class="p">.</span><span class="n">edit</span><span class="p">()</span>
            <span class="p">.</span><span class="n">putString</span><span class="p">(</span><span class="s">&quot;appAuthState&quot;</span><span class="p">,</span> <span class="n">encryptString</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">appAuthState</span><span class="p">.</span><span class="n">jsonSerializeString</span><span class="p">()))</span>
            <span class="p">.</span><span class="n">apply</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>[<a class="reference external" href="https://github.com/paoneJP/AppAuthDemo-Android/blob/da5b3ba59bcd6221c1e19df21657f494047385c5/app/src/main/java/net/paonejp/kndzyb/appauthdemo/MainActivity.kt#L95-L102">⇒GitHubで見る</a>]</p>
<p><span class="docutils literal"><span class="pre">onCreate()</span></span> の中での <span class="docutils literal"><span class="pre">appAuthState</span></span> の復元（一部）</p>
<div class="highlight-kotlin"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>

    <span class="p">...</span>

        <span class="k">val</span> <span class="py">prefs</span> <span class="p">=</span> <span class="n">getSharedPreferences</span><span class="p">(</span><span class="s">&quot;appAuthPreference&quot;</span><span class="p">,</span> <span class="n">MODE_PRIVATE</span><span class="p">)</span>
        <span class="k">val</span> <span class="py">data</span> <span class="p">=</span> <span class="n">decryptString</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">prefs</span><span class="p">.</span><span class="n">getString</span><span class="p">(</span><span class="s">&quot;appAuthState&quot;</span><span class="p">,</span> <span class="k">null</span><span class="p">))</span> <span class="o">?:</span> <span class="s">&quot;{}&quot;</span>
        <span class="n">appAuthState</span> <span class="p">=</span> <span class="n">AuthState</span><span class="p">.</span><span class="n">jsonDeserialize</span><span class="p">(</span><span class="k">data</span><span class="p">)</span>

    <span class="p">...</span>

<span class="p">}</span>
</pre></div>
</div>
<p>[<a class="reference external" href="https://github.com/paoneJP/AppAuthDemo-Android/blob/da5b3ba59bcd6221c1e19df21657f494047385c5/app/src/main/java/net/paonejp/kndzyb/appauthdemo/MainActivity.kt#L62-L64">⇒GitHubで見る</a>]</p>
<p><span class="docutils literal"><span class="pre">encryptoString()</span></span> での暗号化</p>
<div class="highlight-kotlin"><div class="highlight"><pre><span></span><span class="k">fun</span> <span class="nf">encryptString</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="k">data</span><span class="p">:</span> <span class="n">String</span><span class="p">?):</span> <span class="n">String</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">data</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">null</span>
    <span class="p">}</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">val</span> <span class="py">key</span> <span class="p">=</span> <span class="n">getDataEncryptionKey</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
        <span class="k">val</span> <span class="py">c</span> <span class="p">=</span> <span class="n">Cipher</span><span class="p">.</span><span class="n">getInstance</span><span class="p">(</span><span class="s">&quot;AES/CBC/PKCS7Padding&quot;</span><span class="p">)</span>
        <span class="n">c</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">Cipher</span><span class="p">.</span><span class="n">ENCRYPT_MODE</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&quot;%s.%s&quot;</span><span class="p">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">Base64</span><span class="p">.</span><span class="n">encodeToString</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">iv</span><span class="p">,</span> <span class="n">BASE64_FLAGS</span><span class="p">),</span>
                <span class="n">Base64</span><span class="p">.</span><span class="n">encodeToString</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">doFinal</span><span class="p">(</span><span class="k">data</span><span class="p">.</span><span class="n">toByteArray</span><span class="p">()),</span> <span class="n">BASE64_FLAGS</span><span class="p">))</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">ex</span><span class="p">:</span> <span class="n">Exception</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">val</span> <span class="py">m</span> <span class="p">=</span> <span class="n">Throwable</span><span class="p">().</span><span class="n">stackTrace</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
        <span class="n">Log</span><span class="p">.</span><span class="n">e</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span> <span class="s">&quot;${m}: ${ex}&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">null</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>[<a class="reference external" href="https://github.com/paoneJP/AppAuthDemo-Android/blob/da5b3ba59bcd6221c1e19df21657f494047385c5/app/src/main/java/net/paonejp/kndzyb/appauthdemo/util/Crypto.kt#L45-L61">⇒GitHubで見る</a>]</p>
</div>
<div class="section" id="id11">
<h2><a class="toc-backref" href="#id1">所感</a></h2>
<p>AppAuth for Android は非常にわかりやすく、OAuth 2.0 の実装が簡単にできるなと感じました。
今回の実装サンプルのコードも、トータルで600行以下となっていて、少ないコード量で機能を取り込めるところも魅力です。</p>
<p>本文内では触れませんでしたが、 [RFC 8252] OAuth 2.0 for Natvie Apps では、</p>
<ol class="arabic simple">
<li>Authorization Code Grant の利用</li>
<li>OAuth 2.0 PKCE ([RFC 7636] Proof Key for Code Exchange by OAuth Public Clients) の利用</li>
<li>Chrome Custom Tabs もしくはデフォルトブラウザの利用</li>
</ol>
<p>などがベストプラクティスとして示されています。
PKCE への対応やデバイスの状態に応じて利用するブラウザを切り替える実装はかなり面倒なものですが、 AppAuth を利用すれば、今回作った実装サンプルのコードで、サーバーの PKCE への対応状況やデバイスの状態から自動的により望ましい方法を選択して OAuth 2.0 の処理を行なってくれます。</p>
<p>このような環境を作ってくれた、 William Denniss さん、 John Bradley さんをはじめとする、 OAuth 2.0 for Native Apps の発行に携わった皆さん、 AppAuth の開発と公開に携わった皆さんに、とても感謝なのです。</p>
<p><span class="raw-html"><br></span></p>
<p>参考文献</p>
<p>[1] <a class="reference external" href="https://datatracker.ietf.org/doc/rfc8252/">[RFC 8252][BCP 212] OAuth 2.0 for Native Apps</a> <span class="raw-html"><br></span>
[2] <a class="reference external" href="https://datatracker.ietf.org/doc/rfc7009/">[RFC 7009] OAuth 2.0 Token Revocation</a> <span class="raw-html"><br></span>
[3] <a class="reference external" href="https://datatracker.ietf.org/doc/rfc7636/">[RFC 7636] Proof Key for Code Exchange by OAuth Public Clients</a> <span class="raw-html"><br></span>
[4] <a class="reference external" href="https://openid.net/code/AppAuth">AppAuth</a> <span class="raw-html"><br></span>
[5] <a class="reference external" href="https://openid.net/code/AppAuth-Android">AppAuth for Android</a> <span class="raw-html"><br></span></p>
</div>
</div>

    <div class="postmeta">
        <div class="author">
            <span>投稿者 @paoneJP</span>
        </div>
        
        <div class="tags">
            <span>
                タグ:
                <a href="../../../tags/android.html">android</a>, <a href="../../../tags/kotlin.html">kotlin</a>, <a href="../../../tags/appauth.html">appauth</a>, <a href="../../../tags/oauth.html">oauth</a></span>
        </div>
        </div>
    <ul class="related clearfix">
            <li class="left"></li>
            <li class="right"><a href="../../../2016/06/06/config_opendj_as_a_scim_server.html">OpenAM内蔵のOpenDJをSCIM 2.0サーバーとして構成する</a> &raquo; </li>
        </ul></article><aside class="sidebar"><section><div class="widget">
  <h1>書いてる人</h1>
  <!--
  <img src="https://pbs.twimg.com/profile_images/440050792179847168/4OhPuelv.jpeg" width="96" height="96"><br>
  -->
  <img src="https://avatars1.githubusercontent.com/u/6633398?v=3&s=460" width="96" height="96"><br>
  Takashi Yahata
  (<a href="https://twitter.com/paoneJP">@paoneJP</a>)
</div></section><section><div class="widget">
    <h1>最近の投稿</h1>
    <ul><li>
            <a href="#">Kotlin と AppAuth for Android でネイティブアプリの実装サンプルを作ってみた</a>
        </li><li>
            <a href="../../../2016/06/06/config_opendj_as_a_scim_server.html">OpenAM内蔵のOpenDJをSCIM 2.0サーバーとして構成する</a>
        </li><li>
            <a href="../../../2015/07/10/xperia_z4_tablet_projector_output.html">Xperia Z4 Tabletのプロジェクター出力を試す</a>
        </li><li>
            <a href="../../../2015/04/16/building_apache_module_on_various_linux_distro.html">ApacheのモジュールをDebian上でもRHEL/CentOS上でもビルドできるようにする</a>
        </li><li>
            <a href="../../../2015/02/19/openam_persistent_cookie_auth.html">OpenAMのPersistent Cookie認証モジュールで遊んでみる</a>
        </li><li>
            <a href="../../../2015/01/04/openam_wpa_in_same_apache2_instance.html">OpenAMとWeb Policy Agentを同じApacheインスタンスに同居させる [非公式手順]</a>
        </li><li>
            <a href="../../../2015/01/04/openam_wpa_install_on_debian.html">DebianにOpenAM Web Policy Agentをインストールする [非公式手順]</a>
        </li><li>
            <a href="../../../2014/12/21/encrypted_jwt_parsing_trial.html">暗号化されたJWTをパースしてみる</a>
        </li><li>
            <a href="../../../2014/12/21/tinker_theme_customize.html">Tinkererのテーマをカスタマイズする</a>
        </li><li>
            <a href="../../../2014/12/14/easy_setup_instructions_for_openam.html">DTIのVPS上にOpenAMをセットアップしてみた話 [非公式手順]</a>
        </li></ul>
</div>
</section><section><div class="widget" id="searchbox" role="search">
    <h1><a href="#searchbox">Search</a></h1>
    <form action="../../../search.html" method="get">
        <input type="text" name="q" />
        <button type="submit"><span class="fa fa-search"></span></button>
    </form>
</div></section><section><div class="widget">
    <h1>タグ</h1><a href="../../../tags/android.html">android</a> (1), <a href="../../../tags/apache_module.html">apache module</a> (1), <a href="../../../tags/appauth.html">appauth</a> (1), <a href="../../../tags/centos.html">centos</a> (1), <a href="../../../tags/debian.html">debian</a> (8), <a href="../../../tags/idcon.html">idcon</a> (1), <a href="../../../tags/jwt.html">jwt</a> (2), <a href="../../../tags/kotlin.html">kotlin</a> (1), <a href="../../../tags/oauth.html">oauth</a> (1), <a href="../../../tags/openam.html">openam</a> (5), <a href="../../../tags/opendj.html">opendj</a> (1), <a href="../../../tags/openid.html">openid</a> (1), <a href="../../../tags/python.html">python</a> (2), <a href="../../../tags/scim.html">scim</a> (1), <a href="../../../tags/tinkerer.html">tinkerer</a> (1), <a href="../../../tags/vps.html">vps</a> (4), <a href="../../../tags/xperia.html">xperia</a> (1)</div></section><section><div class="widget">
  <h1>ライセンス</h1>
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"> 
  <img alt="クリエイティブ・コモンズ・ライセンス" style="border-width:0"
       src="https://i.creativecommons.org/l/by/4.0/88x31.png"></a><br>
  <font size="-1">
  特に表示をしていない限り、このサイトのコンテンツは
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"> 
  クリエイティブ・コモンズ 表示 4.0 国際ライセンスの下に提供されています。
  </font></a>
</div></section></aside></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo"><footer class="wrapper">&copy; Copyright 2014-2017  @paoneJP. Powered by <a href="http://www.tinkerer.me/">Tinkerer</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.</footer></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>